1. Difference between method and constructor?
    - Constructor should have class name; method can have any name;
    - Method can return value; Constructor can not;
    - We call method with the method name; But we call constructor with "new" key word;
    - A constructor is used to initialize the variables of a Class; A method is used to define the
                                                                    behavior/functionalities of an object
    - Java compiler provides a default constructor; There is no existence of default method.

2. Stream  = Flowing something;

3. Behavior Parameterization
   - is the ability of a method to receive multiple different behavior as
     its parameter and use them internally to accomplish the task.

4. Why is Java so popular?
 - Open Source
    - It is open source, which implies that it it free to use, Any developer with a working knowledge
      of Java can use this free platform to create apps.
 - Built in security
    - It includes high level concurrency tools and packages also take care of security.
 - Strong Community
    - The main reason for Java's popularity is its active and supportive community.
      So, if we ever get trapped in programming, other programmers or the Java community can
      help assist us and solve a problem.
 - Excellent Documentation
    - Its documentation is well-defined and provides complete guide to help and solve any problems.
 - Powerful set of Programming Tools
    - IDE (Integrated Development Environment) is one of Java's most important feature.
      The Java IDE provides a comprehensive editors, debuggers, and collection of automation tools;
    - The three most popular Java IDEs are Eclipse, IntelliJ IDEA, and NetBeans
    - In terms of tools, Java provides Maven for developing Java applications.
    - JConsole and Visual VM work for monitoring Heap utilization
    - Jenkins use for Continuous Integration and Delivery in Java.

5. What are different kind of variables defined in Java?
    - Variable is a container to store a data value. In other words a variable
      is a memory location name for any data.
    - There are 3 kind of variables in Java:
          = Local Variable
                   = Local variables are declared in a blocks, methods, or constructors.
                   = Local variables are created when the block, method, or constructors is started and will be
                     destroyed once it exits the block, method or constructor.
          = Class (Static) Variable
                   = It is declared with the "static" keyword in a class.
                   = A single copy of each static variable is shared by all instances of the class.
                   = Static variables are stored in static memory.
                   = Default values of Static variables:
                             = 0 for numbers;
                             = false/true for boolean;
                             = null for object;
                   = Static variables can be accessed by calling with the class name;
                   = Static variables are initialized only one time.
                   = This variables will be initialized first, before the initialization of any instance variables.
          = Instance Variable
                   = Instance variable are declared outside a method. They are declared in a class.
                   = When object is created the instance variables are created and when object destroyed
                     instance variable is also destroyed.
                   = For instance variables access modifiers can be given.
                   = Instance variables are visible for all methods, constructors, and blocks in the class.
                   = Default values of Instance variables:
                            = 0 for numbers;
                            = false/true for boolean;
                            = null for object;
          = (and Parameter can be also treated as local variable);

6. What is class?
    - A class is a Template, blueprint of an object. A class defines the state and
       behavior that an object can exhibit.

6. What is object?
    - Object is state, behavior of class;
    - Objects are the instance variables of class.
    - Objects are stored through references.
    - Objects are created with new key word.
    - Every object has its own memory.


7. What is state and behavior of an object?
   - Each object has state, behavior and identity.
   - State of an object is stored in field (variables), while methods (functions) display the object's behavior.
   - e.g Cat's state includes its color, size, gender, age, while its behavior is sleeping, purring, meowing for food.
   - The identity is a characteristic used to uniquely identify that object
            = such a random ID number, or an address in memory, ID etc.

8. What is OOP (Object Oriented Programming)?
   - OOP is methodology or paradigm to design a program using classes and objects.
   - OOP is a way of writing computer programs using "objects" to stand for data and methods.

9. What are the key principles of OOP?
    - Inheritance
    - Encapsulation
    - Polymorphism
    - Abstraction

10. What do JVM, JRE and JDK stand for?
                ---------------------------------------

11. How do you swap two numbers?
    - Let say we have two variables x=10, y=20;
    - We can swap this numbers by two different ways:
       1) By Declaring temporary variable

       public class Example {
           public static void main(String[] args) {
               int a = 10;
               int b = 20;
               int temp;

               temp = a;
               a = b;
               b = temp;

               System.out.println("After swapping:" a +""+ b);
           }
       }
       2) By using arithmetic operators

       public class Example {
           public static void main(String[] args) {
               int a = 10;
               int b = 20;

               a = a + b;
               b = a - b;
               a = a - b;

           System.out.println("After swapping:" a +""+ b);
           }
       }

12. Difference Between Array and ArrayList?
    Array:
      - Size Fixed;
      - Dimension Single or Multi
      - Data Type - Primitive or non-primitive
      - Speed - Fast
      - Is a object - Yes

    ArrayList:
      - Size Flexible
      - Dimension - Single
      - Dta Type - Only non-primitive
      - Speed - Slower comparing to Array
      - Is an object - Yes

13. What is String in Java?
    - String is defined as a Class in Java and this class is in java.lang package. It's not a primitive data type like int or double.
    - String class represents sequence of characters
    - there are two ways to create String Object: 1) New Keyword and 2) String literal, in other word we can use assign operator and double quotes.
    - Heap memory also contains string pool. String pool collects String objects which are defined literally.
    - String is immutable, synchronized and thread safe;
    - String class has final keyword and Strings cannot be inherited.

14. What is the difference between stack and heap memory?
    - Stack contains - primitive values, methods, local variables, and reference variables
    - Heap is a section of memory which contains Objects and Instance variables.
      Heap memory also contains String pool.

14. Could you explain static vs non-static in Java?
    - Static:
        - Static is a keyword in Java, it's considered a non-access modifier and can be used with variables or methods.
        - Static members (methods and variables) belong to the class, which means, there will only be one copy of it and will be shared among
          all the instances of that class.
        - To access static members we don't need to create object, we can just use the name of the class.variable/method.
        - Static CAN NOT be overridden but can be overloaded.
      - Non-Static:
        - Non-Static members belong to the instance of the class, so for each object created there will be a copy of them.
        - In order to access a non-static member, we need to first create an object of that class, and then use the object reference
          to make a call upon the method or variable.
        - Can be override and overloaded, both of them.

15. Could you explain method overloading?
   Method Overloading:
        1. Multiple methods that have the same name;
        2. It is performed within class or sub-class;
        3. Parameters must be different;
        4. Access specifier doesn't matter;
        5. Return Time of method doesn't matter, it can be same or different;
        6. All methods included private and final can be overloaded;
        7. Static method can be overloaded;
        8. Abstract method can be overloaded;

16. Could you explain method overriding?
    Method Overriding:
        1. One method with different implementation;
        2. It occurs in two classes that have IS-A relationship;
        3. Parameters must be same;
        4. Access specifier must be same or more visible than original method;
        5. Return type must be same (for primitive and void) or covariant (for object) in method overriding;
        6. private and final methods cannot be overridden;
        7. A static method cannot be overridden but can be hidden by defining a static method with same name and
           parameters in child class.
        8. Abstract method should be overridden;


18. What is primitive type casting?
    - Primitive casting is used to convert primitive values from one data type to another.
    - Casing can be implicit or explicit:
        1)Implicit Casting - when conversion happens automatically, by compiler, without writing specific code to do the conversion.
          Implicit Casting happens when you assign smaller value to a larger data type
        2) Explicit Casting - In explicit casting code must be specifically written. When we try to cast big data type into small one.

19. WildCard?
    - WildCard using as method parameter: public static void printList(List<?> list) - method can accept list of any type (?)
    - Using a wildcard in a generic type parameter -List<?> list = new ArrayList<String>(); - (?) is used as a generic type parameter to
      indicate that the type of the list is unknown.

20. Anonymous class = Without providing class type giving a implementation;

21. what is the difference between flatMap() vs map()?
    - map () takes Stream <T> as input and returns Stream <R>;
    - map () is mapper function produces single values for each input value.
      It is called One-To-One mapping. In one data it will do one action and return that data, one by one.
      e.g Stream.of (1, 2, 3, 4) returns [1, 2, 3, 4]

    -flatMap() takes Stream<Stream<T>> (takes Stream of Stream) as an input and return Stream <R>.
     It is called One-To-Many mapping
     e.g [[1, 2],[3,4,] [4,5],[6,7], [8,9]] returns [1,2, 3, 4, 5, 6, 7, 8, 9] flatMap()

22. What is double column operator?
    - We use double column operator when we call method() directly.
    -e.g System.out::println

23. What is the different findAny() and findFirst() (Stream methods)?
    - findFirst() method always gives you first matching one. It will be always same despite the fact how many times we run program.
    - findAny () method gives you any random matching one. It might change each time we run program.

24. What can be the difference between takeWhile() and limit() methods?
    - takeWhile() method limiting based on the condition (Predicate; eg. less then 500, less then 200 etc);
    - limit() does not accept condition and only limits based on the value (eg. limit 1, limit 2);

25. What is the difference between dropWhile() and skip()?
    - dropWhile() skipping based on the condition(); skip() method skips based on the value you provide(e.g skip 1, skip 2)

26. What is Encapsulation?
    - Encapsulation, along with abstraction, polymorphism and inheritance, is one of the four key concepts in
      object oriented programming (OOP).Encapsulation is data hiding. We use private access modifier to protect data from
      accessing and from modification without permission. To access encapsulated data we use getter() and setter() methods;
    - We can set restrictions using setter method

27. What is inheritance?
    inheritance, along with encapsulation, abstraction and polymorphism is one of the four key concepts in
    object oriented programming. Inheritance is Is A relationship between classes. We have parent/child classes;
    We use "extend" keyWord to inherit one class to another; Extended class is super class.

28. What are inheritance types?
    - MultiLevel Inheritance = Parent -> child -> grandChild
    - Hierarchical Inheritance =  Parent -> child - > child
    - Single Inheritance = Parent -> child;

29. Why do we use inheritance?
    - The most important use of inheritance in Java is code re-usability.
      The code that is present in the parent class can be directly used
      by the child class. Method overriding is also known as runtime polymorphism.

30. What is abstraction?
    - Abstraction is one of the key concept of OPP.
      It is process of hiding implementation details from the user; Only the functionality is provided;
      User will have information what the object does, instead of how it does.

31. What is abstract class?
    - Abstract class meant to be a parent class. Goal is to provide reusable variables and methods
    - Abstract keyword is used to create abstract class
    - An abstract class can not be instantiated;
    - We can not call any methods from abstract class;
    - We can not create object of abstract class;

32. What are the differences between Abstract Classes and Interface?
        = Interface - Can only have final static variables. Interface can never change its own state;
        = Abstract class - can have any static or instance variables, mutable or immutable;
        = A class can implement multiple interfaces;
        = A class can extend only one abstract class
        = Interface Can be implemented with the implements keyword. An interface can also extend interfaces.
        = Abstract class Can only be extended.
        = Only functional interfaces can use the lambda feature in Java.
        = Abstract classes with only one abstract method cannot use lambdas.
        = Interface Can't have constructor.
        = Abstract class can have constructor;
        = Interface can have abstract methods, default and static methods and private methods introduced in java 9;
        = Abstract class can have any kind of methods;

33. What is Polymorphism?
       = Polymorphism is one of the key concept of OOP.
       = The word polymorphism means having many forms, and occurs when we have many classes that are related to each other by inheritance.
         inheritance allows us to inherit attributes and methods from another class.  Polymorphism uses those methods to perform different tasks.
       = A real- life example of polymorphism is a person who at the same time can have different characteristics.

34. What are the types of Polymorphism?
      = There are two main types of polymorphism i.e. runtime polymorphism and compile-time polymorphism.
        Runtime polymorphism is achieved through method overriding, and
        compile-time polymorphism is achieved through method overloading.

35. Give a real world example?
      = A real-life example of polymorphism is a person who at the same time can have different characteristics.
        A man at the same time is a father, a husband, and an employee. So the same
        person exhibits different behavior in different situations.

36. Why and when do we need Polymorphism?
      = Code reuse = it enables you to write more flexible and reusable code by allowing you to treat
        objects of different types as if they were the same type.
      = Method overriding: Polymorphism allows us to override methods in a superclass, providing a specific implementation in a subclass;
      = Interface implementation:  it allows us to define an interface and implement it in multiple classes.
      = Flexibility = Flexible code by separating the interface of an object from its implementation.
37. Procedural programming?
      = Procedural programming is about writing procedures or methods that perform operations on the data.
        it is linear and executes from top to bottom.

38. Benefits of OOP over Procedural Programming?
      = Modularity or re-usability: OOP allows you to modularize your code by encapsulating related data and behavior into objects;
      = Abstraction: OOP allows you to create abstract data types that hide their implementation details.
      = Inheritance and polymorphism: OOP provides inheritance, which allows you to create new classes that are based
        on existing classes and polymorphism, which allows you to treat object of different classes as if they are the same type.
      = Encapsulation: OOP promotes encapsulation, which means that the internal workings are hidden from the outside world. This
        provides better security and reducing the complexity of your code.
      = Code organization: OOP provides a way to organize your code into logical, self contained units, making it easier to manage and understand.

39. Disadvantage of OOP?
      = Complexity: OOP can be complex to read and understand for the developers;
      = It might be overhead in general, that means to be a negative factor in programming as it can lead to slower performance, increased
        memory usage and other issues, that can make a program less efficient of effective.

40. There are 2 type of casting in Polymorphism:
     = Down Casting which means to cast larger reference type to smaller reference type  = that done explicitly;
     = Up Casting which means to smaller reference type to larger reference type = that is done implicitly;
     = There must me Is A relationship between the object type and reference type to be casted.

41. Use of "super" and "this" Key Words?
     = They are special keywords that are used to refer to different objects or methods within a class hierarchy.
     = "Super" is used to refer superclass of the current class. 'Super' keyword is used to call a constructor or method of the superclass from a subclass.
     = "this" is used to refer to a current object instance of a class. Also it calls the methods or constructors within the same class.
     = Overall they are both important keywords in Java that help to manage class hierarchy and distinguish between class-level and
       instance-level variables and methods.

42. What are Solid Principles of OOP?
    = Single Responsibility Principal - You should make sure that functionality are seperated, not good to put everything in one class;
    = The Open-Closed Principle - Class/Module should be open for extension, but closed for modification. That means, you should add
                                  some functionality instead of making changes to the existing one; calculator example, better to create
                                  separate class for each operator, rather than put everything in one class.
    = The Liskov Substitution Principle
              - In simpler terms, this means that any method or property that works on the superclass should also work on
                its subclasses, without any unexpected behavior or errors.
    = The interface Segregation Principle
              - A client should not be forced to implement an interface or it should not depend on a method it does not use;
              - Better to separate methods and create different interfaces;
    = The Dependency Inversion Principle
            - Your code should be Loosely Coupled, not Title Coupled;
            - Instead of creating direct connection between one class to another, better to create something in between.

43. What is the superclass of every class in Java?
    = the superclass of every class is the Object class. The Object class is the root of the class hierarchy, and provides a set of
      common methods that are inherited by all other classes in Java. Some of the common methods provided by the Object class include:

      equals(Object obj) : Compares the object for equality with the given object
      toString() : Returns a string representation of the object
      hashCode() : Returns a hash code value for the object
      getClass() : Returns the class object for the object

44.What is Object class in Java programming language?
    =the Object class is the root of the class hierarchy. It is a built-in class provided by the Java platform, and is located in the java.lang package.

45. Do you remember some of the non-static methods in Object Class?
     = equals(Object obj): This method is used to compare two objects for equality. It returns true if the objects are equal; otherwise, it returns false.
     = hashCode(): This method returns a hash code value for the object. This value is used by hash-based data structures, such as hash maps and hash sets,
       to store and retrieve objects.
     = toString(): This method returns a string representation of the object. The string representation can be used for debugging or logging purposes.

46. Explain the toString() method?
     = it returns string representation. e.g. Person class, we declared person name and age, we should override toString () method, in order to be able to print
        this object in another class we create.
47. What is the use of equals method in Java? How to override it?
     = equals method compares two object to each other, if they are the same or not. e.g person class, declared person name and age. By overriding
        equals method we can compare persons to each other by name and age and we can say if they are the same or not.

        public class Person {
            private String name;
            private int age;

            public Person(String name, int age) {
                this.name = name;
                this.age = age;
            }

            @Override
            public boolean equals(Object obj) {
                if (obj == this) {
                    return true;
                }

                if (!(obj instanceof Person)) {
                    return false;
                }

                Person other = (Person) obj;
                return this.name.equals(other.name) && this.age == other.age;
            }
48. What is the difference between == and equals ()?
   - == operator compares if the objects are same in the memory, if yes true, if not false;
   - equals() method compared content and not the location. if the content is same, returns true, if not, returns false.
   String s1 = "hello";
   String s2 = "hello";
   String s3 = new String("hello");

   System.out.println(s1 == s2); // true
   System.out.println(s1 == s3); // false
   System.out.println(s1.equals(s3)); // true

49. Why do we need Wrapper Classes?
    = Wrapper classes in java provide a way to represent primitive data types as objects. The main reasons for using wrapper classes are:
      1. To treat primitive types as objects: Java is an object-oriented language, and some APIs require objects to be passed as parameters.
      2.To provide utility methods: Wrapper classes provide many useful methods for working with primitive types that are not
        available on the primitive types themselves. For example, the Integer class provides methods to
        convert a string to an integer, or to format an integer as a string.
      3.To provide null values: Primitive types cannot be set to null, whereas objects can. By using wrapper classes,
        we can create nullable objects that can be set to null when no value is present.
      4.To use in collections: Collections in Java can only hold objects, not primitive types.

50. How do you convert a String to Integer?
    = We can use valueOf () method or parse () method.
    Code Example:

        String str = "1234";
        Integer num = Integer.parseInt(str);
        Integer num2 = Integer.valueOf(str);

51. What are the some method of String Class?
        - String class provides wide range of methods.
            1.   length() - Returns the length of the string.
            2.   charAt(int index) - Returns the character at the specified index in the string.
            3.   indexOf(int ch) - Returns the index of the first occurrence of the specified character in the string.
            4.   substring(int beginIndex, int endIndex) - Returns a substring of the string
                 starting at the specified index and ending at the specified index.
            5.   toLowerCase() - Returns the lowercase version of the string.
            6.   toUpperCase() - Returns the uppercase version of the string.
            7.   trim() - Returns a copy of the string with leading and trailing white spaces removed.
            8.   replace(char oldChar, char newChar) - Returns a copy of the string with all occurrences
                 of the specified character replaced with the new character.
            9.   startsWith(String prefix) - Returns true if the string starts with the specified prefix, otherwise false.
            10.  endsWith(String suffix) - Returns true if the string ends with the specified suffix, otherwise false.
            11.  equals(Object anObject) - Returns true if the string is equal to the specified object, otherwise false.
            12.  equalsIgnoreCase(String anotherString) - Returns true if the string is equal to the
                 specified string, ignoring case considerations.
            13.  split(String regex) - Splits the string into an array of substrings based on the
                 specified regular expression.
            14.  concat(String str) - Concatenates the specified string to the end of the current string.

52. The difference between String and StringBuilder:
       - String is immutable; String Builder is mutable (you can manipulate String without creating new object)
       - String is threadSafe, however StringBuilder is not threadSafe;

53. The difference between String and StringBuffer:
       - String is immutable; String Builder is mutable (you can manipulate String without creating new object)
       - String is threadSafe, however StringBuilder is not threadSafe;

54. The difference between StringBuilder and StringBuffer:
       - StringBuffer is thread safe, StringBuilder is not thread safe, however it is faster then StringBuffer.
       - Overall the choice between StringBuffer and StringBuilder depends on the specific requirements;
       - StringBuilder is not Synchronized and StringBuffer is Synchronized.

55. What is constructor?
       - In object-oriented programming, a constructor is a special method that is used to
         initialize an object's state when it is created.
       - The constructor has the same name as the class and is defined without a return type.
       - It is called automatically when an object is created using the new keyword.
       - Constructors can also be overloaded, which means that there can be multiple
         constructors with different parameter lists.

56. What is the difference between Method overloading and Method Overriding?
    Method Overloading:
        1. Multiple methods that have the same name;
        2. It is performed within class or sub-class;
        3. Parameters must be different;
        4. Access specifier doesn't matter;
        5. Return Time of method doesn't matter, it can be same or different;
        6. All methods included private and final can be overloaded;
        7. Static method can be overloaded;
        8. Abstract method can be overloaded;
    Method Overriding:
        1. One method with different implementation;
        2. It occurs in two classes that have IS-A relationship;
        3. Parameters must be same;
        4. Access specifier must be same or more visible than original method;
        5. Return type must be same (for primitive and void) or covariant (for object) in method overriding;
        6. private and final methods cannot be overridden;
        7. A static method cannot be overridden but can be hidden by defining a static method with same name and
           parameters in child class.
        8. Abstract method should be overridden;

57. Difference between constructor and method?
    - Name= Constructor has the same name as the class, method might have different name;
    - Return Type= Constructor doesn't have return time; While method must have return type, or declared as "void";
    - Purpose = Constructor is used to initialized object when it's created, method is used to perform some action;
    - Constructor is automatically called when object is created, while method must be explicitly called by the user.
    - Accessibility: A constructor is always public, while a method can be public, private,
      protected, or package-private.

58. Can a constructor be directly called through the method?
    - A constructor cannot be explicitly called from any method except another constructor. The only place from which you can invoke constructors
        using this() or super() is the first line of another constructor. But, we can call all the members of a class (methods, variables, and constructors)
        from instance methods or constructors.


58. How do you call a superclass constructor from a constructor?
    - We can call constructor from Superclass, from a subclass constructor using super() keyword.

59. What are final classes and final methods of the Java Programming Language?
   =Final Class
    - Final keyword in general is applicable only for class, method or variable;
    - When class is declared final that means it won't be copied, won't be parent of any class.
    - Final class can not be extended and never can be super class. Final keyword prevents inheritance.
  =Final Method
    - Final method can not be overridden.
    - Implementation of the methods becomes unchangeable.
    - However, we can overload any method, even final method.
    - For constructor, as a special method, final method is not applicable;

60. What are access and non-access modifiers that can be added to a class or class-member declaration?
    - There are 4 types of access modifiers, the difference is only visibility/ accessibility.
          - public - visible in the same class and package and outside the same package if you call through the class
          - Protected - visible/accessible inside the same class and package. Not visible outside the same package
                        Protected is accessible outside the same package if we declare it in subclass.
          - Default - Never visible outside the same package.
          - Private - only accessible from the same class.
    - Non-access modifiers modify the behavior of a class or class member in various ways, but do not affect its accessibility.
          - "final" = indicates that a class or class members cannot be further extended or modified.
          - 'Static' = indicates that a class member belongs to the class itself, rather than to any instance of the class.
          - 'abstract' = indicates that a class or class member is incomplete and must be implemented by a subclass.
          - synchronized = indicates that a method can only be accessed by one thread at a time.

61. What are exceptions in Java programming language?
    -  Exception is an event that occurs during the execution of a program, which disrupts the normal flow of the program's instructions.
    -  When an exception occurs, the program execution is terminated and exception object is created to provide information about the error,
       including the type of the exception.
       Exceptions can occur due to different reasons, such as invalid input, incorrect code logic, or unexpected system errors.
    -  There are 3 types of exceptions in Java:
        1. Checked Exception = exceptions when compiler gives error
        2. Unchecked exceptions = exceptions when happens run time, such as NullPointerException, ArrayIndexOutBoundsException, ArithmeticException.
        3. Errors = There are exceptions that indicate a serious problem that cannot be handled by the program. E.g. OutOfMemoryError, StackOverflowError.

62. Why is exception handling important?
    - Exception handling is important for several reasons:
        - Prevent program crashes
        - Improve user experience: Exception handling can help improve the user experience by providing more informative error messages.
            Instead of simply crashing or displaying a generic error message, programs can display specific messages that inform users about the problem.
        - Debugging - Exception handling can also make it easier to debug programs. When an exception is thrown, developers can use the information provided
          to locate the source of the problem and fix it.
        - Maintain program flow: Exception handling allows programs to maintain their flow even when unexpected situations occur. By catching and handling exceptions,
          programs can continue to execute without being interrupted by errors.
        - Code re-usability: Exception handling makes code more reusable by allowing developers to write code that can handle a variety of different situations.
          Instead of writing separate code for each possible error scenario, developers can write a single piece of code that handles multiple exceptions.

63. Difference between errors and exceptions?
        - Exceptions are subclasses of the Exception class, while errors are subclasses of the Error class.
        - Exceptions are typically caused by application -level problems, while errors are caused by system-level problems.
        - Exceptions can be handled through try-catch blocks or by declaring them in a method's throws clause, while errors cannot be handled in the same way.
          Errors indicate serious problems, like our-of-memory errors or hardware failures.
        - Exceptions and errors are both types of runtime problems in Java, but they differ in their types, handling, and severity.

64.  what happens when you throw the checked exception from a method?
        -

65. How do you handle exceptions?
        1) Try-catch block = it helps to catch and handle exceptions that occur within a block of code.
            Try block contains the code that may throw an exception, and the catch block contains the code that handles the exception.
            Syntax:
            try {
            //tryBlock statement

            }catch (ExceptionClass e){

            //catch block statement
            //handle exception
            }
        2)  throws keyword: = the throws keyword is used to declare that a method may throw a checked exception.
            Syntax:

            public void myMethod() throws IOException {

             //code that may throw on IOException
            }

66. How can you use throw clause?
       - 'throw' key word explicitly throws exception from a method or block of code.
       - The 'throw' clause is used to throw a specific exception object, which can be any class that extends the "Throwable" class.

      public void myMethod (int value) throws IllegalArgumentException {
      if (value < 0) {
      throw new IllegalArgumentException ("Value cannot be negative")
      }

      //code that executes if value is not negative;
   }

   1) create method and inside the method we need to pass exception instance that extends the "Throwable" class, such as 'Exception' or 'RuntimeException.'
   2. "throw" statement should be inside a method or block of code.

67. how does Java programming language pass variables to methods? by values or by reference?
    - In Java variables are passed to methods by values, not by reference.
    - Java passes variables to method by value, which means that any changes made to the variable within the method do not affect
      the original variable outside the method.

68. Difference between throws and throw keyword?
    throws = is used in the method signature to indicate that the method may throw one or more exceptions. This allows the
    caller of the method to handle or propagate the exception.
    throw = is used to explicitly throw an exception from a method or block of code;

69. Why do we need to finally block?
    The finally block always executes when the try block exits. This ensures that the finally block is executed
    even if an unexpected exception occurs. But finally is useful for more than just exception handling — it
    allows the programmer to avoid having cleanup code accidentally bypassed by a return, continue, or break.
    Putting cleanup code in a finally block is always a good practice, even when no exceptions are anticipated.
    The finally block is a key tool for preventing resource leaks. When closing a file or
    otherwise recovering resources, place the code in a finally block to ensure that resource is always
    recovered.


                    e.g. try {
                         //body
                    } catch (IndexOutOfBoundsException e) {
                        //body
                    } catch (IOException e){
                      //body
                    }finally {
                      //body
                    }


70. Can you catch more than one type of exception in a single catch block?
    In Java SE 7 and later, a single catch block can handle more than one type of exception. This feature can
    reduce code duplication.
    In the catch clause, specify the types of exceptions that block can handle, and separate each exception
    type with a vertical bar (|):
                    catch (IOException|SQLException ex) {
                     logger.log(ex);
                     throw ex;
                    }

71. Can you have multiple catch blocks?
    Yes we can have. Each catch block handles a specific exception.

72. Is try without catch and finally allowed?
    No, try needs at least one of them. Otherwise JVM would give a Compilation Error!! (End of try block)

73. Can you try and finally block without the catch block in java programming language?
    Yes, we can have a finally block without the catch block.

74.What happens when a catch block throws an exception?
   When an exception is thrown in the catch block, the program stops the execution.

75. How can you stop finally block from being executed?
     Finally block, always runs (even we put “return” keyword inside the catch block) except system is
     terminated by:
     • System.exit(0); in the catch block.
     • JVM crash.

76.  What is the difference between final, finally and finalize?
     • Final : keyword. Can be used for variables, methods, and classes.
     • Finally : block, can be used only with try & catch blocks. Always gets executed regardless of the
       exception.
     • Finalize: method, garbage collector uses before destroying the unreferenced objects. Implicitly done.


77. How do you create a Custom Exception?
    Yes we can create our own exceptions, customized according to user needs, derived from classes of the Exception class.
    We can create custom exceptions by extending the Exception or RuntimeException class, depending on whether we want
    our exception to be checked or unchecked.

78. How do you throw an exception from a method?
    Let’s assume that we have a method named addAmounts in Class AmountAdder which adds amounts. If
    amounts are of different currencies, it throws an exception by using throw keyword.
                method:
                static Amount addAmounts(Amount amount1, Amount amount2) {
                if (!amount1.currency.equals(amount2.currency)) {
                throw new RuntimeException("Currencies don't match");
                }
                return new Amount(amount1.currency, amount1.amount + amount2.amount);
                }
               }
               public cl

79. Do you remember any method of Exception class?
    printStackTrace(): prints the stack trace of the exception.
    getMessage(): returns the detail message of the exception.
    getStackTrace(): returns an array of stack trace elements, each representing one stack frame.
    getCause(): returns the cause of the exception.

80.What could be the reason if you are getting NullPointerException?
       • Attempting to invoke a method on a null reference (we cannot call any method or variable with this
          variable).
       • Attempting to access or modify an instance variable of a null reference (null keyword doesn’t refer
         to any object).
       • Attempting to use an uninitialized variable.
       • Passing a null reference to a method that does not allow null values.
       • Attempting to auto-unbox a null object.

81. What is class cast exception?
    -- There must be IS-A relationship between classes
    -- If you try to down cast one reference type to another without IS-A relationship, you get this
       exception.

82.Can you explain the hierarchy of Exception Handling classes?
   Throwable is the highest level of Error handling classes.
   ● class Error extends Throwable{}
   ● class Exception extends Throwable {}
   ● class RuntimeException extends Exception {}


83. What is @Component and @ComponentScan?
    - We mark class with @Component which we want Spring to create and manage objects and add an instance into its context;
    - We mark configuration class with @ComponentScan to tell Spring where to find the classes you
      marked for being managed by the framework.
    - Stereotype annotations can be only used for classes that we can change:
        @Component --> @Controller--> @Service --> @Repository

84. What is @Configuration?
    - We use this annotation to identify configuration class.
    -  A configuration class is a class that provides configuration information to the Spring container.
    - It is used to define beans, wire dependencies between beans, and configure other aspects of the
      Spring application context.

85. How to add beans to Spring context via annotation?
   there are 2 ways:
    1. @Configuration claas we declare methods that return objects.
       @Bean - we use method level annotation

    2. Using stereotype annotations (@Component, @Service, @Repository, @Controller)

86. What is the difference between @Bean and Stereotype Annotations?
      ● Stereotype is class-level annotations, @Bean is method level
      ● Stereotype annotations only for custom made class. @Bean can be always used.

87. What is a dependency?
    Relationship between two components of a software system, where one component has a relationship with another.

88. What is dependency injection (DI)?
    DI is a core concept in Spring.
    Instead of creating an object's dependencies internally, inside each class, the dependencies are "injected"
    from the outside.
    DI reduced boilerplate codes and helped developers to create modular, maintainable, and testable code.

89. How do you implement dependency injection (DI) in Spring?
    There are 3 ways in which we can use the @Autowired annotation:
      = Constructor injection (best practice)
      = Setter Injection
      = filed injection

90. What is Auto Wiring?
    Auto Wiring and DI is related concepts but they are different. DI is a patter in which the dependencies
    of a class are injected into it from the outside, rather than being created inside the class itself.
    DI allows loose coupling.

    AutoWiring on the other hand, is a mechanism in Spring that facilitates dependency injection.

91. What does @Autowired signify?
    Spring @Autowired annotation is used for automatic dependency injection.
    When a bean is
    annotated with @Autowired, Spring will automatically search for a bean of the same type and inject it into the
    bean that is being created.

92. What is “@Primary”?
    If more than one bean of the same type is available in the container, the framework will throw
    NoUniqueBeanDefinitionException indicating that more than one bean is available for auto wiring. With
    @Primary, we give higher preference to a bean when there are multiple beans available of the same type.

93.What is “@Qualifier”?
   @Qualifier annotation along with @Autowired can be used to remove the confusion by specifying which
   exact bean will be wired.

94.What is the difference between @Primary and @Qualifier annotations?
   @Qualifier is very specific, we can identify more than one bean with @Qualifier, while @Primary give preference only
   one bean and defines it default.

95. What is the default scope of a bean?
    there are 2 type of scopes:
        - Singleton which is default and everytime we request a reference Spring provides the same object.
        - prototype: everytime we request a reference Spring creates a new object.

96.What is the bean life cycle in Spring Bean Factory Container?
   The lifecycle of any object means when & how it is instantiated and when and how it is destroyed.
   When we run the program been instances are instantiated and finally, the bean is destroyed when the spring
   container is closed.
   Overview how Spring manages the lifecycle of a bean:
        - Bean instantiation:
        - Dependency injection
        - Initialization when spring calls any methods
        - Ready to use - once initialization is complete
        - Destruction - when application is shutting down.

97.Are Spring beans thread safe?
   The thread-safety of Spring beans depends on their scope and implementation.
   e.g Singleton which means that there is only one instance of the bean in the application context.
       Singleton beans are shared among multiple-threads and their thread safety is depends on their implementation.


3. What is the Collections Framework?
    - Collection in Java is a framework that provides an architecture to store and manipulate the group of objects.
    - Java collections can achieve all the operations that you perform on a data such as searching, sorting,
    insertion, manipulation, and deletion.
    - Interfaces
        =Set
        =List
        =Queue
        =Deque
    - Classes
        =ArrayList
        =Vector,
        =LinkedList
        =PriorityQueue
        =HashSet
        =LinkedHashSet
        =TreeSet
    - Advantage of Collection is: It reduces programming effort and increases performance

4. Why do we need collection in Java?
   Advantage of Collection is: It reduces programming effort and increases performance.

5. What are the key interfaces defined in Java collection?
   - Queue, List, Dequeue, Set

6. When we need to use List, Set and Queue?
   List = is an ordered collection of elements, we can access each elements using index. Insertion order of elements
          is maintained; ArrayList and LinkedLIst classes are commonly used implementations of List interface
          e.g sequence of tasks in a specific order.
   Set = is a collection of unique elements. We use set if we want to enforce uniqueness of elements and when we don't
         care about insertion order. HashSet and TreeSet classes are commonly implementations of Set interface;
         e.g user IDs or email addresses.
   Queues = is a collection of elements that supports adding elements at one end and removing elements from the other end.
            We use Queues when we want to manage collection in FIFO order. ArrayDeque and LinkedList are commonly used
            implementations of the queue interface.
            e.g processing tasks in the order in which they were received.

7. What is LinkedList? How it is different then Array List? What Interfaces LinkedList Implements?
   LinkedList implements 2 interfaces = List and Queues.
   The main difference between ArrayList and LinkedList is the way how they handel adding, accessing and removing
   elements;
     - Memory wise, LinkedList is more efficient, then ArrayList. e.g we need to add 1 element to an Arraylist with million
   elements inside, we need to increase size by 50%. While in case of linked-list we can increase size by 1.
    - when we remove element from ArrayList, after removing elements need to be shift and its expensive; while in
      LinkedList we can just remove element and update neighboring nodes;
    - Accessing elements in ArrayList can be directly done using index, which is O(1) operation, while in LInkedList

8. What is the difference between add and set method of the List?
    add method adds a new element to the end of the list or at a specified index,
    while the set method replaces an existing element at a specified index with a new one.
    e.g. list.add (element); or list.add(index, element);
         list.set (index, element);

9. Can you briefly explain the Set Interface?
     Set is a collection of unique elements. We use set if we want to enforce uniqueness of elements and when we don't
     care about insertion order. HashSet and TreeSet classes are commonly implementations of Set interface;
      e.g user IDs or email addresses.

10. What is the difference between Set and SortedSet interface?
    Order: Set isn't sorted, SortedSet is sorted in order;
    Operation: SortedSet provides additional operations to manipulate the order, like: first(), last(), headSet();
               These operations aren't available in Set interface;
    Implementations: SortedSet implements -> treeSet
                     Set implements -> LinkedHashSet, HashSet, EnumSet;

11. What are the difference between Set, List and Queue?
    Set = No duplicates
    List = Insertion order is preserved, allows duplicates
    Queue = Returns elements First in First out.

12. What are the core implementations classes of Set interface?
    LinkedHashSet, TreeSet, HashSet

13.What is HashSet?
   It is a class that implements the Set interface;
   Some key features of HasSet are:
    - Uniqueness, allows no duplicates
    - Null values, it is allowed
    - The performance of the basic operations (add, remove and contains) is constant-time O(1)
    - for the HashSet timeComplexity is O(1)

14. Difference between LinkedHashSet and HashSet?

    Order: HashSet - doesn't guarantee any particular order, it has random order, while
           LinkedHashSet guarantees insertion order, without duplicates;
    Implementation: = HashSet uses hashtable data structure to store the data, while LinkedHashSet uses both
                       hash Table and linked list;

15. Difference between HashSet and TreeSet?
    Ordering: TreeSet stores elements in a sorted order, while HashSet does not guarantee any particular order;
    HashSet = accepts null
    TreeSet = doesn't accepts null

16. Collection Interface important methods?
    add (E e) - adds elements if it's not added
    addAll(Collection <? extends E> c): adds all of the elements in the specified collection to this collection.
    clear()
    contains (object o)
    isEmpty()
    iterator();
    remove(Object o)
    size()
    toArray() = returns Array

17. What is Spring Boot?
    Spring Boot is an open source framework, that provides a rapid application development environment.
    Spring Boot includes features like auto-configuration, which automatically configures the application
    based on the dependencies.
    It also includes embedded servlet container, such as Tomcat or Jetty, which eliminates the need for
    a separate configuration.

18. What is Spring Initializr?
    It is a web based tool, that provides an easy way to generate a new Spring Boot project with all
    necessary dependencies and configurations.
    Dependencies can be customized according to developer's needs.
    Overall it simplifies the process of setting up and new Spring Boot project.

19. How to run the spring boot application?
    1. Build the project like Maven or Gradle.
    2. Locate the executable file, which s typically a Jar file in the target directory
    3. Run the application.
    4. Verify the application is running. After running application we should see some output in the console
        indicating that the application has started. After running we should be able to navigate to the URL
        http://localhost:8080

19.What are the differences between Spring and Spring Boot?
   Spring and Spring Boot are both frameworks for Java Applications, but differences are goes and approach.
   1. Configuration - Spring requires explicit configuration and Spring Boot provides automatic configuration
   2. Dependencies - SpringBoot includes a set of opinionated dependencies that are commonly
      used in Spring application - such as Spring Data, Spring Web, Spring Security.
      Spring on the other hand requires manual configuration.
   3.Embedded Server - Spring Boot includes Tomcat or Jetty, but Spring does not.
   4.Complexity- Spring Boot is designed to reduce the complexity of Spring application by providing
                 automatic configuration. Spring on the other hand has customized options.

20. What is Spring Boot DevTools Used for?
    1. Automatic Restart: Key feature is automatic restart, when a change is made to the app code, the application
       is automatically restarted.
    2. Live reload: also support live reload, which allows developers to see changes made to HTML, CSS files
    3. Overall it increases productivity and is helpfully for developers.

21. What are core annotations of SpringBoot?
    @SpringBootApplication = main annotation to configure a spring boot
    @Controller = marking class as controller
    @Service
    @RequestMapping - to map URL to a method in a controller class
    @Autowired - to inject Dependencies.
    @Component - marking class as a Spring Bean.

22. What is @SpringBootApplication annotation?
    It is a main annotation to configure a spring boot and includes: @Configuration,
    @EnableAutoConfiguration, and @ComponentScan.

23. What is Application Properties?
     It is a simple text file named "application.properties" that is located in the "src/main/resources"
     directory of the project.
     1. To store API keys and other sensitive information, which can be accessed using syntax ${}
     2. Server Port: to define the server port from where application should listen for incoming HTTP requests.
     3. Security settings: Username/password properties.

24. What is the difference between @configurationProperties and @Value?
    @ConfigurationProperties is more powerful and flexible for injecting external
    configurations into a Spring bean, as it provides type-safe binding and default values.
    However, if you only need to inject a single property value, @Value may be more convenient.

25. Can we change the port of the embedded Tomcat Server?
    Yes, you can change the port of the embedded Tomcat Server in a Spring Boot
    application by setting a property in your application.properties or application.yml file.

    For example, if you want to change the port to 8081, you can add the following property
    to your application.properties file: server.port = 8081

26. What is starter parent?
    In Spring Boot, starter parent is a special parent POM (Project Object Model) that provides
    default configuration, dependencies, an plugins for Spring Boot app. It provides:
    1. Default configuration
    2. Default Dependencies
    3. Dependency management

27. Advantages of Spring Boot?
    1. Easy to get started = We can run application with minimal configuration.
    2. It provides features such as embedded servers, security checks, logging and monitoring
    3. Spring Boot is build on top of Spring framework and integrates seamlessly with other spring projects,
      such as Spring Data, Spring Security, Spring Cloud.
    4. Community support.

WEEK_11

28. MVC Stands for?
    Model, View, Controller. MVC is used for developing software applications. It divides app into 3 interconnected
    components: the Model, the view and the controller.

    Model: is responsible for managing the application's data and business logic, such as data validation,
           database interactions and calculations. It represents the rules and information that govern the
           behavior of the application.
    View: is responsible for presenting the data to the user in a format that is easy to understand and interact
           with. It includes user interfaces such as web pages, forms or graphical interfaces.
    Controller: acts as a intermediary between the Model and the view. It receives view from the user and
                updates the Model accordingly. It also takes care of updating the view with the latest data from
                the Model.
    MVC pattern: provides a separation of concerns, which makes it easier to maintain and extend the application.
                 It allows developers to work simultaneously on different parts of application without
                 interfering with each other. Additionally, MVC pattern promotes re-usability of code, as
                 the components can be used in different app with minimum modification
    Spring MVC: is web framework that implements the MVC pattern in Java-based web applications.
                It helps developers to build maintainable, scalable app.

29. What is Model in Spring?
    In Spring MVC Model is represented by an interface called Model, which provides methods to add
    remove and retrieve attributes from the model. A model object can be created in the controller
    by returning a ModelAndView object, which contains both the model and the view name, or by using
    the @ModelAttribute annotation on a method parameter.

30. Can you explain controller method in Spring MVC?
    A controller method is responsible for processing incoming requests from clients and returning a
    response. It is a method within a controller class that is annotated with the @RequestMapping
    annotation, which maps the method to a specific endpoint URL.
    A method may have any name, but must have a return type and may have parameters. Return type can be
    view name, a ModelAndView object, or an object to be converted to JSON or XML format using a message converter.

31. Can you explain a simple flow in Spring MVC?
    1. User send HTTP request to the server (Tomcat)
    2. Tomcat get the HTTP request and calls Dispatcher Servlet or Front Controller.
    3. Dispatcher Servlet is responsible for finding what controller action to call
       for the request and what to send back in response to the client. Dispatcher servlet
       delegates finding proper controller to a component names Handler Mapping.
    4. Dispatcher Servlet calls specific controller action.
    5. Controller performs the necessary processing and packs the response data in a model,
        send Model and View name to Dispatcher Servlet.
    6. DS delegates the responsibility of getting the view content to a component names view resolver.
    7. DS returns the rendered view in the HTTP response.

32. What is Dispatcher Servlet?
    It is the central front controller in the Spring MVC web framework. DS is responsible for handling
    many of the common tasks involved in processing HTTP requests, including:
        - Parsing the request URL and identifying the appropriate controller method to handle the request;
        - Extracting data from the request and passing it to the controller method.
        - Managing the lifecycle of the web application context and other Spring components.
        - Rendering the response by invoking the appropriate view resolver and view technology

33. What is View Resolver?
    It is a component in Spring MVC that is responsible to return correct view to the dispatcher servlet.
     When controller method returns a modelAndView object, viewResolver uses view name to look up the appropriate view
     implementation based on a set of configured rules.

34. What is @RequestMapping?
    @RequestMapping is a Spring annotation that is used define the URL path and the HTTP request method (GET, POST, PUT, DELETE etc)
    that the controller can handle. It can be applied to class level, or method level in a container.

35.  What is the difference between @RequestMapping and @GetMapping?
    @RequestMapping is generic, we can use it with GET, POST, PUT and any other request methods, using the method attribute on the annotation
    while,
    @GetMapping is specific to the GET request method. It just improve clarity and is easy to read the code.

36. What is @PathVariable?
    It is responsible to bind URL value to the method variable and retrieve data into the database.
    We pass @PathVariable as a method parameter.

37. What is @RequestParam?
    It is used to indicate that a method parameter should be bound to a URL template variable.
    Structure is different, we pass value as key -> value;
    A request parameter is mandatory by default. If the client does not provide a value for the request
    parameter, the server sends back a response with the status HTTP 400 Bad Request.

38.  How is server-side validation done using Spring MVC?
     The Spring MVC validation is used to restrict the input provided by the user.
     The Spring uses Bean Validation API to validate the user's input (sprint-boot-starter-validation dependency).
     The Validation API is a Java specification that is used to apply constraints on DTO via annotations in javax.validation.constraints.

39. What is BindingResult?
    BindingResult is an interface that represents binding results of form data. It is used together with
    @ModelAttribute to perform validation of form data submitted by the user.
    When a form is submitted, Spring MVC will try to bind the form data to a model object using @ModelAttribute.
    If there are any validation errors, Binding Result will capture those errors and allow the controller to handle them appropriately.

40. What is @modelAttribute?
    @ModelAttribute can be used either as a method parameter or at the method level.
    When used as a method argument, it indicates the argument should be retrieved from the model.
    Spring MVC does this behind the scenes before invoking the submit method.
    At the method argument level @ModelAttribute might be used to customize the name of the attribute.

    When it is used at the method level, it shows the method adds an attribute to all models defined in the controller class.
    Spring MVC will always make a call first to that method before it calls any request handler methods.
    @ModelAttribute method are invoked before the controller methods  are annotated with @RequestMapping.

41. How do you set the default date format with Spring?
    @DateTimeFormat tag can be used for the date fields in the Entity or DTO classes.

42. Explain what is Thymeleaf and how to use Thymeleaf?
    Thymeleaf: provides a good support serving an HTML5 in web application.
                   To integrate Thymeleaf with Spring Boot, we need to add: spring-boot-starter-thymeleaf.
                   To convert HTML to Thymeleaf, we need to add attribute, xmlns: th="http://thymelead.org"
                   When we put this link, that means we bring thymeleaf library from online.
    Thymeleaf is a java-based library used to create a web application. To able to integrate Thymeleaf with Spring Boot, we need to add
    the "spring-boot-starter-thymeleaf" dependency.
           - We need to use Template Engine and pass the variable to html
            - Thymeleaf is most famous template engine, because its end point is html.


43.  Explain the difference between Spring Boot, Spring MVC, and Spring?
       Spring: The core spring framework provides a foundation for developing enterprise-level applications.
                  It provides wide range of features and services, including dependency injection, data access, security,
                  and web development.
      Spring MVC: Spring MVC is a web application framework, that is built on top of the Spring Framework.
                 MVC stand for Model -View-Controller.  Spring MVC is designed to simplify the development of web applications.

       Spring Boot: It is framework for building microservices and standalone applications.
                  It is also built on top of Spring Framework and provides a streamlined development experience by reducing boilerplate
                  codes and provides ready configuration. It includes embedded server and a range of ready dependency configurations
                  which makes it easy to start the application.



-------------------------------SPRING---------------------------------
1. Can you give a big picture of the Spring?
    Spring came into being in 2003 as a response to the complexity of job in Development;
    1st component of SPRING was IoC container.
    We refer to Spring as a framework, but it is much more complex, like an ecosystem.
    Spring's ecosystem includes: Spring data, Spring Security, Spring Cloud, Spring Boot.

    Advantages:
       - Simplified development;
       - Scalability. Can easily handle large applications
       - Testability - easier to write automated tests for applications, resulting in faster development cycles and more reliable software.
       - Flexibility - it is flexible and can be used with various programming languages, frameworks and tools.
       - Security
       - Community Support
2. What are important Spring Modules?
    - Spring Core (IoC) - It is fundamental feature of Spring, including dependency injection, bean lifecycle management,
      and inversion of control;
    - Spring Boot - It provides easy way to create application with minimal configuration. Includes features such as auto-configuration,
        embedded servers.
    Spring MVC - It provide Model-View-Controller framework for building web applications. It includes features such as
        requestMapping, view resolution, and support for various web technologies.
    Spring Data - It provides model for data access in Spring -based applications.
    Spring Security - It provides a security framework for Spring -based app. It includes features such as authentication, authorization,
        and support for various security mechanisms.
    Spring Cloud - It provides tools for building and deploying microservices-based applications. It includes features such
      as service discovery, load balancing and circuit breaking.
3. why is Spring popular?
    There are several reasons:
        1. Modularity: It is  a modular framework, which means developers can use only the modules they need and leave out the rest.
        2. Dependency Injection: Simplifies coding part and coding amount.
        3. Integration with other frameworks: It integrates with other popular frameworks such as Hibernate, Struts, and JSF.
        4. Open-source
        5. Strong Community

4. What is coupling?
    Coupling refers to the degree of interdependence between two or more components (class, interface, method, module etc) in a software system.
    It is a measure of how closely one component depends on another component to perform its function.
          There are 2 types of coupling = Tight and Loose coupling

5. What is IoC?
    With IoC the control is inverted and the framework or container controls the flow of the program by creating and managing the components
      calling their methods.
      In the context of the Spring framework, IoC is achieved using dependency injection (DI). DI is a design pattern
      that allows objects to be loosely coupled by injecting their dependencies

6. What are the advantages of IoC container?
    Loose coupling;
    Reliability;
    Testability;
    Configurability
    Scalability
    Consistency

7. What are the important roles of an IOC Container?
   They are:
    - Dependency Injection
    - Configuration Management - Spring IoC container can be used to configure components in a system by specifying their properties,
        behaviors, and dependencies. This configuration is typically stored in XML files, Java Annotations or java-based configuration classes.
    - Object Creation and management:IoC creates and manages lifecycle of objects in a system. It can create objects on demand.
    - Scope Management

8. What is bean?
Spring Bean is simply Java object. A bean is an object that is created and managed by Spring Container.
Spring beans are created from POJOs.

9. What are the types of IoC container in Spring? Please explain them briefly.
    1. BeanFactory:  The BeanFactory is lightweight and suitable for small to medium-sized applications. The
                    objects are initialized lazily, which means they are created only when they are requested.
    2. ApplicationContext:
        provides all the functionality of the BeanFactory and adds additional features such as internationalization,
        resource handling;


14. How did you learn Spring Boot?
    - First I learned Spring Core -> IoC, DI
    - Then I learned MVC - Model, View, Controller
    - The I leaned Spring Data - Hibernate (ORM), JPA, Repository (Derived, JPQL, Native Query)
    - Spring Security Subject  - create Authorization (login), create Authentication (different users, role access, what you
                                 are going to do in this application); We learned fundamentals of Security.
    - Spring API
    - Spring Security
    - Spring AOP
    - Spring Testing

     - DevOps
     - MicroService


-------------------------------------------Maven----------------------------------
1. What is Maven?
        Maven is an open-source build management tool developed by Apache Software Foundation. We use Maven for creating
        projects, managing dependencies, building and testing software, and deploying application via Project
        Object Model (POM) and plugins.

2. What is meant by the term ‘Build Tool’?
    Some commonly used build tools in the Spring ecosystem include:
        1. Apache Maven: Maven
        2. Gradle
   Build tools in Spring are used to perform tasks such as managing dependencies,
   compiling source code, running tests, creating executable JAR (Java Archive) files,
   and deploying applications to different environments.

3. What are the main features of Maven?
   - Dependency Management
   - Build Lifecycle management (such as compile, test, package, install, and deploy)
   - Convention over Configuration = Maven uses conventions and best practices to simplify the build
                                     process.
   -  Customization with plugins = There are many plugins available for Maven, including plugins for code
                                   coverage, static analysis, and deployment.
    - Model Based builds = Maven is able to build any number of projects into predefined output types
                           such as a JAR, WAR.
   -  Integration with IDEs=  Maven integrates with popular Java IDEs such as Eclipse, IntelliJ IDEA, and
      NetBeans. This allows developers to manage dependencies and build their projects from within the
      IDE.

4. How does Maven work?
   Maven architecture works in three steps, which are as follows:
     -> The first step is to read the
         pom.xml file.
     -> Then, it downloads the
        dependencies defined in pom.xml
        into the local repository from the
        central repository.
     ->  Finally, it builds and generates a
         report based on the
         requirements, as well as handles
         life cycles, phases, goals, plugins,
         and other tasks

5. What is POM?
   POM stands for Project Object Model.
   It includes information about the project's name, version, packaging type, and dependencies. In addition
   to the basic project information, the POM file can also define plugins that provide additional functionality
   during the build process.
   The POM file is located in the root directory of the project and has a standard name of "pom.xml".
   When we run a Maven command, such as "mvn compile" or "mvn package," Maven reads the POM file to
   determine the project's configuration and dependencies, and then executes the appropriate build phases
   and plugins.

6.  What does POM contain?
        • Project Information: This includes the project's name, description, version, and packaging type
        (JAR, WAR, etc.).
        • Project Dependencies
        • Build Configuration: This section includes the build configuration settings such as the source and
        output directories, plugins, and goals.
        • Plugin Configuration: This section contains the configuration for each plugin used in the project.
        • Project Repositories: This section lists the repositories used for dependency resolution and
        deployment.
        • Project Profiles: Profiles allow you to customize the build process for different environments or
        situations. They can include additional dependencies, plugins, and configuration settings.
        • Parent POM: This section allows a project to inherit configuration and settings from a parent POM

7.What are the different types of Maven repositories?
    - Local Repository _ Developer's device
    - Central Repository - The maven community has built the central Maven repository
    - Remote Repository - Maven may download dependencies from a remote repository hosted on a web server.

8. What is Maven Build Lifecycle?
    Each lifecycle consists of a series of phases, which represents a specific stage of the build process.
    The Maven build lifecycle consists of three built-in lifecycles:
        1) Clean - removes all generated files and artifacts created during the previous build
        2) Default - handles the project compilation, test and deployment. It compiles the source code, runs
           tests, and generates output artifacts such as JAR files or WAR files.
        3) Site -  It handles the creation of our project's web site. This phase also generates documentation and
                  reports that provide useful information about the project, such as project status, code quality, and
                  test coverage.
9. What are the main build phases in default lifecycle?
    validate = validates the project is correct
    compile = compile the source code of the project
    test = test the compiled source code using a suitable unit testing framework.
    package = take the compiled code and package in its distributable format, such as
              jar, war, ear.
    verify = run any checks on results of integration tests to ensure quality criteria are met.
    install = install the package into the local repository, for use as a dependency in other projects locally.
    deploy = done in the build environment, copies the final package to the remote repository for sharing with
             other developers and projects.


10. What is Maven Artifact?
    In Maven, an artifact is a packaged, distributable unit of software that is produced by the build process.
    An artifact can be a JAR, a WAR, a ZIP file, or any other file format that can be deployed or installed.

11. What are Maven plugins used for?
        Plugins are commonly used in various software frameworks and platforms to add custom functionality,
        tailor the software to specific requirements, or extend its capabilities beyond the base functionality
        provided by the core system. Plugins can be developed by the original software authors or by third-party developers,
        and they can be distributed and shared among users to enhance their software experience.

        Plugins can be included in a project's POM file and can be executed at different phases of the build
        lifecycle. For example, the Maven Compiler plugin is used to compile source code into bytecode during the
        compile phase, while the Maven Surefire plugin is used to run tests during the test phase.

12. What is Archetype?
    An archetype is a template or blueprint that provides a starting point for creating a new project.
    Archetypes define the structure and configuration of a project, including the project's directory structure,
    build configuration, dependencies, and other settings.

13. How do we check if the expressions are balanced with the opening and closing delimiters in Stack ?
    If opening and closing symbols are balanced and if they match other one the expression is balanced.
            e.g. (A+B)+(C-D) -> Balanced
                  ((A+B)+(C-D) -> Not Balanced


